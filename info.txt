=================================================================================
                     FOODIEEXPRESS PROJECT DOCUMENTATION
                          Complete API & Agent Specification
=================================================================================

Project: FoodieExpress - AI-Powered Food Delivery Platform
Version: 4.0.0
Date: October 15, 2025
Database: MongoDB Atlas
AI Model: Ollama llama3.2:3b (Local)

=================================================================================
                      1. COMPLETE API CONTRACT
=================================================================================

Base URL: http://localhost:8000
Documentation: http://localhost:8000/docs (Swagger UI)

--- PUBLIC ENDPOINTS (No Authentication Required) ---

[1.1] GET / - Welcome Endpoint
URL: GET /
Request Body: None
Response (200):
{
  "message": "Welcome to FoodieExpress API!",
  "version": "4.0.0",
  "features": [
    "AI Chatbot",
    "Multi-Item Orders",
    "Reviews & Ratings",
    "Cuisine Search",
    "Admin Dashboard",
    "Business Intelligence",
    "Personalized Recommendations",
    "Distributed Tracing"
  ]
}

[1.2] GET /restaurants/ - Get All Restaurants
URL: GET /restaurants/
Query Parameters:
  - cuisine (optional): Filter by cuisine type (case-insensitive)
    Example: ?cuisine=Gujarati
Request Body: None
Response (200):
[
  {
    "name": "Swati Snacks",
    "area": "Ashram Road, Ahmedabad",
    "cuisine": "Gujarati",
    "items": [
      {
        "item_name": "Masala Thepla",
        "price": 120.0,
        "rating": 4.5,
        "total_ratings": 200,
        "description": "Traditional Gujarati flatbread",
        "image_url": null,
        "calories": 250,
        "preparation_time": "15 mins"
      }
    ]
  }
]
Error Responses:
  - 500: {"detail": "Error fetching restaurants: [error message]"}

[1.3] GET /restaurants/{restaurant_name} - Get Restaurant by Name
URL: GET /restaurants/{restaurant_name}
Path Parameters:
  - restaurant_name: Exact name of the restaurant
Request Body: None
Response (200):
{
  "name": "Swati Snacks",
  "area": "Ashram Road, Ahmedabad",
  "cuisine": "Gujarati",
  "items": [...]
}
Error Responses:
  - 404: {"detail": "Restaurant 'XYZ' not found"}
  - 500: {"detail": "Error fetching restaurants: [error message]"}

[1.4] GET /search/items - Search Restaurants by Menu Item
URL: GET /search/items?item_name=Pizza
Query Parameters:
  - item_name (required): Name of the menu item (case-insensitive)
Request Body: None
Response (200):
[
  {
    "name": "Manek Chowk Pizza",
    "area": "Manek Chowk, Ahmedabad",
    "cuisine": "Italian",
    "items": [...]
  }
]
Error Responses:
  - 422: Missing required parameter "item_name"
  - 500: {"detail": "Error searching for item: [error message]"}

[1.5] GET /restaurants/{restaurant_name}/reviews - Get Restaurant Reviews
URL: GET /restaurants/{restaurant_name}/reviews
Query Parameters:
  - limit (optional): Number of reviews (1-100, default: 10)
  - skip (optional): Number to skip for pagination (default: 0)
Request Body: None
Response (200):
[
  {
    "id": "507f1f77bcf86cd799439011",
    "user_id": "507f191e810c19729de860ea",
    "username": "john_doe",
    "restaurant_name": "Swati Snacks",
    "rating": 5,
    "comment": "Excellent food and service!",
    "review_date": "2025-10-15T10:30:00Z",
    "helpful_count": 10,
    "is_verified_purchase": true
  }
]
Error Responses:
  - 404: {"detail": "Restaurant 'XYZ' not found"}

[1.6] GET /restaurants/{restaurant_name}/reviews/stats - Get Review Statistics
URL: GET /restaurants/{restaurant_name}/reviews/stats
Request Body: None
Response (200):
{
  "restaurant_name": "Swati Snacks",
  "total_reviews": 50,
  "average_rating": 4.5,
  "rating_distribution": {
    "1": 2,
    "2": 3,
    "3": 5,
    "4": 15,
    "5": 25
  }
}
Error Responses:
  - 404: {"detail": "Restaurant 'XYZ' not found"}

[1.7] GET /health - Health Check
URL: GET /health
Request Body: None
Response (200):
{
  "status": "healthy",
  "version": "4.0.0",
  "database": "connected",
  "features": ["reviews", "admin_dashboard", "ai_personalization", "docker"]
}

--- AUTHENTICATION ENDPOINTS ---

[2.1] POST /users/register - Register New User
URL: POST /users/register
Request Body:
{
  "username": "john_doe",           // 3-30 chars, alphanumeric + underscore/hyphen
  "email": "john@example.com",      // Valid email format
  "password": "SecurePass123",      // 8-128 chars, must have letters + numbers
  "role": "user"                    // Optional: "user" or "admin" (default: "user")
}
Response (201):
{
  "id": "507f191e810c19729de860ea",
  "username": "john_doe",
  "email": "john@example.com",
  "role": "user"
}
Error Responses:
  - 400: {"detail": "An account with this email already exists"}
  - 400: {"detail": "An account with this username already exists"}
  - 422: Validation errors (e.g., password too short, invalid email)

[2.2] POST /users/login - Login and Get JWT Token
URL: POST /users/login
Rate Limit: 5 requests per minute per IP
Request Body (Form Data):
  username: john_doe
  password: SecurePass123
Response (200):
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "bearer"
}
Error Responses:
  - 401: {"detail": "Incorrect username or password"}
  - 429: {"error": "Rate limit exceeded"} (Too many login attempts)

[2.3] GET /users/me - Get Current User Info
URL: GET /users/me
Authentication: Required (Bearer Token)
Headers:
  Authorization: Bearer <access_token>
Request Body: None
Response (200):
{
  "id": "507f191e810c19729de860ea",
  "username": "john_doe",
  "email": "john@example.com",
  "role": "user"
}
Error Responses:
  - 401: {"detail": "Not authenticated"}
  - 401: {"detail": "Invalid authentication credentials"}

--- ORDER ENDPOINTS (Authentication Required) ---

[3.1] POST /orders/ - Create New Order
URL: POST /orders/
Authentication: Required (Bearer Token)
Request Body:
{
  "restaurant_name": "Swati Snacks",
  "items": [
    {
      "item_name": "Masala Thepla",
      "quantity": 2,                 // 1-100
      "price": 120.0                 // 0-10000
    },
    {
      "item_name": "Dhokla",
      "quantity": 1,
      "price": 80.0
    }
  ]
}
Response (201):
{
  "id": "507f1f77bcf86cd799439011",
  "user_id": "507f191e810c19729de860ea",
  "restaurant_name": "Swati Snacks",
  "items": [...],
  "total_price": 320.0,
  "status": "placed",
  "order_date": "2025-10-15T10:30:00Z"
}
Error Responses:
  - 401: {"detail": "Not authenticated"}
  - 404: {"detail": "Restaurant not found"}
  - 422: Validation errors:
    - Quantity <= 0 or > 100
    - Price < 0 or > 10000
    - No items in order
    - More than 50 items in order

[3.2] GET /orders/ - Get User's Orders
URL: GET /orders/
Authentication: Required (Bearer Token)
Request Body: None
Response (200):
[
  {
    "id": "507f1f77bcf86cd799439011",
    "user_id": "507f191e810c19729de860ea",
    "restaurant_name": "Swati Snacks",
    "items": [...],
    "total_price": 320.0,
    "status": "placed",
    "order_date": "2025-10-15T10:30:00Z"
  }
]
Error Responses:
  - 401: {"detail": "Not authenticated"}

[3.3] GET /orders/{order_id} - Get Specific Order
URL: GET /orders/{order_id}
Authentication: Required (Bearer Token)
Request Body: None
Response (200):
{
  "id": "507f1f77bcf86cd799439011",
  "user_id": "507f191e810c19729de860ea",
  "restaurant_name": "Swati Snacks",
  "items": [...],
  "total_price": 320.0,
  "status": "placed",
  "order_date": "2025-10-15T10:30:00Z"
}
Error Responses:
  - 401: {"detail": "Not authenticated"}
  - 403: {"detail": "You don't have permission to view this order"}
  - 404: {"detail": "Order not found"}

--- REVIEW ENDPOINTS (Authentication Required) ---

[4.1] POST /restaurants/{restaurant_name}/reviews - Submit Review
URL: POST /restaurants/{restaurant_name}/reviews
Authentication: Required (Bearer Token)
Request Body:
{
  "restaurant_name": "Swati Snacks",  // Must match URL parameter
  "rating": 5,                         // 1-5 stars
  "comment": "Excellent food!"         // 10-1000 characters
}
Response (201):
{
  "id": "507f1f77bcf86cd799439011",
  "user_id": "507f191e810c19729de860ea",
  "username": "john_doe",
  "restaurant_name": "Swati Snacks",
  "rating": 5,
  "comment": "Excellent food!",
  "review_date": "2025-10-15T10:30:00Z",
  "helpful_count": 0,
  "is_verified_purchase": true
}
Error Responses:
  - 401: {"detail": "Not authenticated"}
  - 400: {"detail": "You have already reviewed this restaurant"}
  - 400: {"detail": "Restaurant name in URL must match request body"}
  - 404: {"detail": "Restaurant 'XYZ' not found"}
  - 422: Validation errors:
    - Rating not between 1-5
    - Comment less than 10 or more than 1000 characters

[4.2] PUT /reviews/{review_id} - Update Review
URL: PUT /reviews/{review_id}
Authentication: Required (Bearer Token, Owner Only)
Request Body:
{
  "rating": 4,                    // Optional: 1-5 stars
  "comment": "Updated review"     // Optional: 10-1000 characters
}
Response (200):
{
  "id": "507f1f77bcf86cd799439011",
  "user_id": "507f191e810c19729de860ea",
  "username": "john_doe",
  "restaurant_name": "Swati Snacks",
  "rating": 4,
  "comment": "Updated review",
  "review_date": "2025-10-15T10:30:00Z",
  "helpful_count": 0,
  "is_verified_purchase": true
}
Error Responses:
  - 401: {"detail": "Not authenticated"}
  - 403: {"detail": "You can only update your own reviews"}
  - 404: {"detail": "Review not found"}
  - 422: Validation errors (same as create review)

[4.3] DELETE /reviews/{review_id} - Delete Review
URL: DELETE /reviews/{review_id}
Authentication: Required (Bearer Token, Owner Only)
Request Body: None
Response (204): No content
Error Responses:
  - 401: {"detail": "Not authenticated"}
  - 403: {"detail": "You can only delete your own reviews"}
  - 404: {"detail": "Review not found"}

[4.4] GET /users/me/reviews - Get My Reviews
URL: GET /users/me/reviews
Authentication: Required (Bearer Token)
Request Body: None
Response (200):
[
  {
    "id": "507f1f77bcf86cd799439011",
    "user_id": "507f191e810c19729de860ea",
    "username": "john_doe",
    "restaurant_name": "Swati Snacks",
    "rating": 5,
    "comment": "Excellent food!",
    "review_date": "2025-10-15T10:30:00Z",
    "helpful_count": 0,
    "is_verified_purchase": true
  }
]
Error Responses:
  - 401: {"detail": "Not authenticated"}

--- ADMIN-ONLY ENDPOINTS (Authentication + Admin Role Required) ---

[5.1] POST /restaurants/ - Create Restaurant
URL: POST /restaurants/
Authentication: Required (Bearer Token + Admin Role)
Request Body:
{
  "name": "New Restaurant",
  "area": "SG Highway, Ahmedabad",
  "cuisine": "Italian",
  "items": [
    {
      "item_name": "Margherita Pizza",
      "price": 350.0,
      "rating": 4.5,
      "total_ratings": 100,
      "description": "Classic Italian pizza",
      "image_url": null,
      "calories": 800,
      "preparation_time": "20 mins"
    }
  ]
}
Response (201): Restaurant object
Error Responses:
  - 401: {"detail": "Not authenticated"}
  - 403: {"detail": "Admin privileges required"}
  - 400: {"detail": "Restaurant with this name already exists"}

[5.2] PUT /restaurants/{restaurant_name} - Update Restaurant
URL: PUT /restaurants/{restaurant_name}
Authentication: Required (Bearer Token + Admin Role)
Request Body: Same as create restaurant
Response (200): Updated restaurant object
Error Responses:
  - 401: {"detail": "Not authenticated"}
  - 403: {"detail": "Admin privileges required"}
  - 404: {"detail": "Restaurant not found"}

[5.3] DELETE /restaurants/{restaurant_name} - Delete Restaurant
URL: DELETE /restaurants/{restaurant_name}
Authentication: Required (Bearer Token + Admin Role)
Request Body: None
Response (200):
{
  "message": "Restaurant 'XYZ' deleted successfully"
}
Error Responses:
  - 401: {"detail": "Not authenticated"}
  - 403: {"detail": "Admin privileges required"}
  - 404: {"detail": "Restaurant not found"}

[5.4] GET /admin/stats - Get Platform Statistics
URL: GET /admin/stats
Authentication: Required (Bearer Token + Admin Role)
Request Body: None
Response (200):
{
  "total_users": 150,
  "total_orders": 500,
  "total_revenue": 50000.0,
  "orders_today": 25,
  "revenue_today": 3500.0,
  "active_users_last_7_days": 80,
  "total_reviews": 200,
  "average_rating": 4.5
}
Error Responses:
  - 401: {"detail": "Not authenticated"}
  - 403: {"detail": "Admin privileges required"}

[5.5] GET /admin/orders - Get All Orders
URL: GET /admin/orders
Authentication: Required (Bearer Token + Admin Role)
Request Body: None
Response (200): Array of all orders
Error Responses:
  - 401: {"detail": "Not authenticated"}
  - 403: {"detail": "Admin privileges required"}

[5.6] GET /admin/users - Get All Users
URL: GET /admin/users
Authentication: Required (Bearer Token + Admin Role)
Request Body: None
Response (200):
[
  {
    "id": "507f191e810c19729de860ea",
    "username": "john_doe",
    "email": "john@example.com",
    "role": "user"
  }
]
Error Responses:
  - 401: {"detail": "Not authenticated"}
  - 403: {"detail": "Admin privileges required"}

=================================================================================
                      2. AI AGENT TOOLS (COMPLETE LIST)
=================================================================================

Agent Framework: Flask (Python)
AI Model: Ollama llama3.2:3b (Local)
Port: 5000
Backend API: http://localhost:8000

--- AVAILABLE TOOLS ---

[Tool 1] get_all_restaurants() -> str
Purpose: Fetches all available restaurants from the backend
Parameters: None
Returns: Formatted string with restaurant list
API Call: GET /restaurants/
Example Usage: User says "list all restaurants"
Example Output:
  "Here are the restaurants I found! ðŸª
  
  â€¢ **Swati Snacks** in Ashram Road, Ahmedabad (Cuisine: Gujarati)
  â€¢ **Agashiye The House of MG** in Lal Darwaja, Ahmedabad (Cuisine: Gujarati)"

Function Definition:
def get_all_restaurants():
    """Get all restaurants from backend"""
    api_url = f"{FASTAPI_BASE_URL}/restaurants/"
    print(f"DEBUG: Calling API at URL: {api_url}")
    try:
        response = requests.get(api_url, timeout=5)
        response.raise_for_status()
        restaurants = response.json()
        if not restaurants:
            return "I couldn't find any restaurants available at the moment."
        result = "Here are the restaurants I found! ðŸª\n\n"
        for i, r in enumerate(restaurants, 1):
            result += f"â€¢ **{r['name']}** in {r.get('area', 'N/A')} (Cuisine: {r.get('cuisine', 'N/A')})\n"
        return result
    except requests.exceptions.RequestException as e:
        print(f"ðŸ”´ FATAL ERROR in get_all_restaurants: {e}")
        return "ðŸ”Œ Sorry, I'm having trouble connecting to the restaurant service."

[Tool 2] search_by_cuisine(cuisine: str) -> str
Purpose: Search restaurants by cuisine type
Parameters:
  - cuisine (str): Cuisine name (e.g., "Gujarati", "Italian")
Returns: Formatted string with filtered restaurant list
API Call: GET /restaurants/?cuisine={cuisine}
Example Usage: User says "show me gujarati restaurants"
Example Output:
  "ðŸ” Here are the **Gujarati** restaurants I found:
  
  1. **Swati Snacks** - ðŸ“ Ashram Road, Ahmedabad
  2. **Agashiye The House of MG** - ðŸ“ Lal Darwaja, Ahmedabad"

Function Definition:
def search_by_cuisine(cuisine):
    """Search restaurants by cuisine"""
    api_url = f"{FASTAPI_BASE_URL}/restaurants/?cuisine={cuisine}"
    try:
        response = requests.get(api_url, timeout=5)
        response.raise_for_status()
        restaurants = response.json()
        if not restaurants:
            return f"I couldn't find any {cuisine} restaurants at the moment."
        result = f"ðŸ” Here are the **{cuisine}** restaurants I found:\n\n"
        for i, r in enumerate(restaurants, 1):
            result += f"{i}. **{r['name']}** - ðŸ“ {r.get('area', 'N/A')}\n"
        return result
    except requests.exceptions.RequestException as e:
        print(f"ðŸ”´ FATAL ERROR in search_by_cuisine: {e}")
        return "ðŸ”Œ Sorry, I'm having trouble connecting to the restaurant service."

[Tool 3] get_restaurant_by_name(name: str) -> str
Purpose: Get detailed information about a specific restaurant
Parameters:
  - name (str): Restaurant name (exact match)
Returns: Formatted string with restaurant details and menu
API Call: GET /restaurants/{name}
Example Usage: User says "tell me about Swati Snacks"
Example Output:
  "ðŸª **Swati Snacks**
  ðŸ“ Location: Ashram Road, Ahmedabad
  ðŸ´ Cuisine: Gujarati
  
  ðŸ“‹ **Menu:**
  â€¢ Masala Thepla - â‚¹120
  â€¢ Dhokla - â‚¹80"

Function Definition:
def get_restaurant_by_name(name):
    """Get specific restaurant details"""
    api_url = f"{FASTAPI_BASE_URL}/restaurants/{name}"
    try:
        response = requests.get(api_url, timeout=5)
        response.raise_for_status()
        r = response.json()
        result = f"ðŸª **{r['name']}**\n"
        result += f"ðŸ“ Location: {r.get('area', 'N/A')}\n"
        result += f"ðŸ´ Cuisine: {r.get('cuisine', 'N/A')}\n\n"
        result += "ðŸ“‹ **Menu:**\n"
        for item in r.get('menu', []):
            result += f"â€¢ {item.get('item_name', 'N/A')} - â‚¹{item.get('price', 0)}\n"
        return result
    except requests.exceptions.HTTPError as e:
        if e.response.status_code == 404:
            return f"I couldn't find a restaurant named '{name}'."
        return "ðŸ”Œ Sorry, I'm having trouble connecting to the restaurant service."
    except requests.exceptions.RequestException as e:
        return "ðŸ”Œ Sorry, I'm having trouble connecting to the restaurant service."

[Tool 4] search_by_item(item_name: str) -> str
Purpose: Find which restaurants serve a specific menu item
Parameters:
  - item_name (str): Name of the food item
Returns: Formatted string with restaurants that have this item
API Call: GET /search/items?item_name={item_name}
Example Usage: User says "which restaurants have pizza?"
Example Output:
  "ðŸ” Great news! Here are the restaurants serving **Pizza**:
  
  1. **Manek Chowk Pizza** - ðŸ“ Manek Chowk, Ahmedabad"

Function Definition:
def search_by_item(item_name):
    """Search which restaurants have specific item"""
    api_url = f"{FASTAPI_BASE_URL}/restaurants/search/item?item_name={item_name}"
    try:
        response = requests.get(api_url, timeout=5)
        response.raise_for_status()
        restaurants = response.json()
        if not restaurants:
            return f"I couldn't find any restaurants that serve {item_name}."
        result = f"ðŸ” Great news! Here are the restaurants serving **{item_name}**:\n\n"
        for i, r in enumerate(restaurants, 1):
            result += f"{i}. **{r['name']}** - ðŸ“ {r.get('area', 'N/A')}\n"
        return result
    except requests.exceptions.RequestException as e:
        print(f"ðŸ”´ FATAL ERROR in search_by_item: {e}")
        return "ðŸ”Œ Sorry, I'm having trouble connecting to the restaurant service."

[Tool 5] call_ollama(messages, system_prompt) -> str
Purpose: General conversational AI for non-tool queries
Parameters:
  - messages (list): Conversation history
  - system_prompt (str): System instructions
Returns: AI-generated response
API Call: POST http://localhost:11434/api/chat (Ollama)
Example Usage: User says "hello" or "how are you?"
Function Definition:
def call_ollama(messages, system_prompt):
    """Call Ollama API"""
    try:
        payload = {
            "model": OLLAMA_MODEL,
            "messages": [{"role": "system", "content": system_prompt}] + messages,
            "stream": False
        }
        response = requests.post(OLLAMA_URL, json=payload, timeout=30)
        if response.status_code == 200:
            return response.json()["message"]["content"]
        return "Error communicating with AI"
    except Exception as e:
        return f"AI Error: {str(e)}"

--- TOOL ROUTING LOGIC ---

The agent uses keyword matching to route user queries to appropriate tools:

Trigger: "list" + "restaurant" â†’ get_all_restaurants()
Trigger: "which" + ("has" OR "have") â†’ search_by_item()
Trigger: "gujarati" OR "italian" OR "chinese" â†’ search_by_cuisine()
Trigger: "tell me about" OR "menu" â†’ get_restaurant_by_name()
Default: All other queries â†’ call_ollama()

=================================================================================
                      3. FULL AI AGENT SYSTEM PROMPT
=================================================================================

System Prompt (Stored in SYSTEM_INSTRUCTION variable):

"""
You are a friendly FoodieExpress chatbot assistant. ðŸ•

Your capabilities:
- Help users browse restaurants
- Search by cuisine or food item
- Show restaurant menus
- Assist with orders

When users ask about restaurants, USE THESE TOOLS:
- "list all restaurants" â†’ call get_all_restaurants()
- "gujarati restaurants" â†’ call search_by_cuisine(cuisine)
- "tell me about X" â†’ call get_restaurant_by_name(name)
- "which has bhel?" â†’ call search_by_item(item_name)

Be friendly, use emojis, and be helpful!
"""

Agent Personality Traits:
- Friendly and conversational
- Uses emojis for engagement
- Provides structured, easy-to-read responses
- Proactive in offering suggestions
- Handles errors gracefully with user-friendly messages

Limitations (Current Implementation):
- Does NOT handle order placement (no place_order tool yet)
- Does NOT handle user authentication (no login/register tools)
- Does NOT handle reviews (no review tools)
- Context handling is LIMITED (simple keyword matching, no deep NLU)
- Cannot remember previous conversation beyond current session
- Cannot access user order history

=================================================================================
                      4. BUSINESS RULES & LOGIC
=================================================================================

--- A. ORDERING LOGIC ---

[Rule 4.1] Invalid Quantity Handling
Question: What happens if user orders quantity 0 or -1?
Answer: API returns 422 Unprocessable Entity
Validation: Pydantic schema enforces quantity >= 1
Schema Code:
  quantity: int = Field(..., ge=1, le=100)
  @field_validator('quantity')
  def validate_quantity(cls, v):
      if v <= 0:
          raise ValueError("Quantity must be at least 1")
      return v

[Rule 4.2] Maximum Quantity per Item
Question: What is the maximum allowed quantity for a single item?
Answer: 100 items per line item
Enforcement: Pydantic Field validation
Schema Code:
  quantity: int = Field(..., ge=1, le=100)
Error if exceeded: 422 with message "Maximum quantity per item is 100"

[Rule 4.3] Maximum Items per Order
Question: What is the maximum number of different items in one order?
Answer: 50 different items
Enforcement: Pydantic Field validation
Schema Code:
  items: List[OrderItemCreate] = Field(..., min_length=1, max_length=50)

[Rule 4.4] Price Validation
Question: What are the price limits?
Answer: Price must be between 0 and 10,000 rupees
Enforcement: Pydantic Field validation
Schema Code:
  price: float = Field(..., ge=0, le=10000)

[Rule 4.5] Restaurant Existence Check
Question: What happens if user orders from non-existent restaurant?
Answer: API returns 404 Not Found
Implementation: main.py checks restaurant exists before creating order
Code Logic:
  restaurant = await Restaurant.find_one(Restaurant.name == order_data.restaurant_name)
  if not restaurant:
      raise HTTPException(status_code=404, detail="Restaurant not found")

[Rule 4.6] Total Price Calculation
Question: Who calculates the total price?
Answer: Backend calculates total = sum(item.price * item.quantity)
Implementation: Prevents client-side price manipulation
Code:
  total_price = sum(item.price * item.quantity for item in order_data.items)

[Rule 4.7] Order Status
Question: What is the initial order status?
Answer: "placed"
Implementation: Hardcoded in Order creation
Future: Could add statuses like "preparing", "out_for_delivery", "delivered"

--- B. REVIEW LOGIC ---

[Rule 4.8] Duplicate Review Prevention
Question: Can a user submit multiple reviews for the same restaurant?
Answer: NO - Only one review per user per restaurant
Enforcement: Backend checks for existing review before creation
Error: 400 Bad Request with message "You have already reviewed this restaurant"
Code:
  existing_review = await Review.find_one(
      Review.user_id == current_user.id,
      Review.restaurant_name == restaurant_name
  )
  if existing_review:
      raise HTTPException(status_code=400, detail="You have already reviewed...")

[Rule 4.9] Update Existing Review
Question: How can users change their review?
Answer: Use PUT /reviews/{review_id} to update rating and/or comment
Restriction: Users can only update their own reviews (ownership check)

[Rule 4.10] Review Without Ordering
Question: Can users review restaurants they've never ordered from?
Answer: YES - But review is marked as NOT verified
Implementation: Backend checks if user has ordered from restaurant
Code:
  user_order = await Order.find_one(
      Order.user_id == current_user.id,
      Order.restaurant_name == restaurant_name
  )
  is_verified = user_order is not None

[Rule 4.11] Rating Range Validation
Question: What ratings are allowed?
Answer: 1 to 5 stars (integers only)
Enforcement: Pydantic Field validation
Schema Code:
  rating: int = Field(..., ge=1, le=5)
Error if violated: 422 with message "Rating must be between 1 and 5"

[Rule 4.12] Comment Length Validation
Question: What are comment length requirements?
Answer: Minimum 10 characters, Maximum 1000 characters
Enforcement: Pydantic Field validation
Schema Code:
  comment: str = Field(..., min_length=10, max_length=1000)

[Rule 4.13] XSS Protection
Question: How are reviews sanitized?
Answer: Automatic removal of HTML/JavaScript tags
Implementation: Pydantic field_validator in ReviewCreate schema
Removes: <script>, <iframe>, javascript:, on*= attributes

[Rule 4.14] Restaurant Name Consistency
Question: Must review's restaurant_name match URL parameter?
Answer: YES - Both must be identical
Enforcement: Backend validation
Code:
  if review_data.restaurant_name != restaurant_name:
      raise HTTPException(status_code=400, detail="Restaurant name mismatch")

--- C. AUTHENTICATION & USER LOGIC ---

[Rule 4.15] Password Strength Requirements
Requirements:
  1. Minimum 8 characters
  2. Maximum 128 characters
  3. Must contain at least ONE letter (A-Z or a-z)
  4. Must contain at least ONE number (0-9)
Enforcement: Pydantic @field_validator in UserCreate schema
Code:
  @field_validator('password')
  def validate_password_strength(cls, v: str):
      if len(v) < 8:
          raise ValueError("Password must be at least 8 characters")
      if not re.search(r'[A-Za-z]', v):
          raise ValueError("Must contain at least one letter")
      if not re.search(r'\d', v):
          raise ValueError("Must contain at least one number")
      return v

[Rule 4.16] Username Requirements
Requirements:
  - 3-30 characters
  - Only alphanumeric, underscore (_), and hyphen (-) allowed
  - Must be unique across all users
Enforcement: Pydantic pattern validation + DB uniqueness check
Schema Code:
  username: str = Field(..., min_length=3, max_length=30, 
                       pattern="^[a-zA-Z0-9_-]+$")
Error: 400 if username already exists

[Rule 4.17] Email Validation
Requirements:
  - Must be valid email format (validated by EmailStr)
  - Must be unique across all users
Enforcement: Pydantic EmailStr + DB uniqueness check
Error: 400 if email already exists

[Rule 4.18] JWT Token Expiration
Question: How long does an access token last?
Answer: 30 minutes
Configuration: ACCESS_TOKEN_EXPIRE_MINUTES = 30 (in security.py)
Implementation: JWT token includes "exp" claim
User Action: After 30 minutes, user must login again

[Rule 4.19] Password Hashing
Implementation: Bcrypt via passlib
Security: Passwords are NEVER stored in plain text
Bcrypt Limit: 72 bytes (passwords truncated if longer)
Code (security.py):
  pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

[Rule 4.20] Login Rate Limiting
Question: How many login attempts are allowed?
Answer: 5 attempts per minute per IP address
Enforcement: SlowAPI rate limiter on /users/login
Error: 429 Too Many Requests if exceeded
Purpose: Prevent brute force password attacks
Code:
  @limiter.limit("5/minute")
  async def login_for_access_token(...)

--- D. ADMIN LOGIC ---

[Rule 4.21] Admin-Only Endpoints
Question: Which endpoints require admin role?
Answer: The following 6 endpoints:

1. POST /restaurants/ - Create new restaurant
2. PUT /restaurants/{restaurant_name} - Update restaurant
3. DELETE /restaurants/{restaurant_name} - Delete restaurant
4. GET /admin/stats - View platform statistics
5. GET /admin/orders - View all orders
6. GET /admin/users - View all users

Enforcement: Depends on get_current_admin_user dependency
Code (dependencies.py):
  async def get_current_admin_user(current_user: User = Depends(get_current_user)):
      if current_user.role != "admin":
          raise HTTPException(status_code=403, 
                            detail="Admin privileges required")
      return current_user

[Rule 4.22] Admin Role Assignment
Question: How does a user become an admin?
Answer: Must set role="admin" during registration
Current Implementation: Self-service (insecure for production)
Production Recommendation: Only existing admins should create new admins
Code:
  user = User(
      username=user_data.username,
      email=user_data.email,
      hashed_password=hashed_pass,
      role=user_data.role if user_data.role else "user"
  )

[Rule 4.23] Admin Cannot Access Other Users' Private Data
Question: Can admins view other users' passwords?
Answer: NO - GET /admin/users returns users WITHOUT hashed_password
Implementation: Manual filtering in response
Code:
  return [{
      "id": str(user.id),
      "username": user.username,
      "email": user.email,
      "role": user.role
      # hashed_password is NOT included
  } for user in users]

[Rule 4.24] Admin Statistics Calculation
Question: How are platform stats calculated?
Answer: Real-time aggregation from database
Implementation:
  - total_users: User.count()
  - total_orders: len(await Order.find_all())
  - total_revenue: sum of all order.total_price
  - orders_today: orders with order_date >= today 00:00:00
  - active_users_last_7_days: unique user_ids with orders in last 7 days
Performance Note: This is inefficient for large datasets (use MongoDB aggregation pipeline)

--- E. DATA VALIDATION RULES ---

[Rule 4.25] Restaurant Name Length
Range: 2-100 characters
Enforcement: Pydantic Field validation

[Rule 4.26] Menu Item Name Length
Range: 2-100 characters
Enforcement: Pydantic Field validation

[Rule 4.27] Maximum Menu Items per Restaurant
Limit: 200 items
Enforcement: Pydantic Field validation
Code: items: list[RestaurantItem] = Field(default=[], max_length=200)

[Rule 4.28] Cuisine Name Length
Range: 2-50 characters
Enforcement: Pydantic Field validation

[Rule 4.29] Area/Location Name Length
Range: 2-100 characters
Enforcement: Pydantic Field validation

[Rule 4.30] Item Price Range
Range: 0 to 10,000 rupees
Enforcement: Pydantic Field validation
Code: price: Optional[float] = Field(None, ge=0, le=10000)

[Rule 4.31] Calorie Count Range
Range: 0 to 5,000 calories
Enforcement: Pydantic Field validation
Code: calories: Optional[int] = Field(None, ge=0, le=5000)

[Rule 4.32] Item Description Length
Maximum: 500 characters
Enforcement: Pydantic Field validation

[Rule 4.33] Review Pagination Limits
Question: How many reviews can be fetched at once?
Answer: Minimum 1, Maximum 100 (default 10)
Enforcement: Query parameter validation
Code:
  limit: int = Query(10, ge=1, le=100)
  skip: int = Query(0, ge=0)

--- F. ERROR HANDLING RULES ---

[Rule 4.34] 401 Unauthorized
Triggered When:
  - No Authorization header provided
  - Invalid JWT token (expired, malformed, wrong signature)
  - Token belongs to non-existent user
Response: {"detail": "Not authenticated"} or {"detail": "Invalid credentials"}

[Rule 4.35] 403 Forbidden
Triggered When:
  - User tries to access admin-only endpoint without admin role
  - User tries to update/delete another user's review
  - User tries to view another user's order
Response: {"detail": "Admin privileges required"} or 
          {"detail": "You can only update your own reviews"}

[Rule 4.36] 404 Not Found
Triggered When:
  - Restaurant name doesn't exist in database
  - Order ID doesn't exist
  - Review ID doesn't exist
Response: {"detail": "Restaurant 'XYZ' not found"} or 
          {"detail": "Order not found"}

[Rule 4.37] 422 Unprocessable Entity
Triggered When:
  - Pydantic validation fails (wrong data types, out of range, regex mismatch)
  - Missing required fields
  - Field violates constraints (e.g., password too short, quantity > 100)
Response: Detailed error with field name and validation message
Example:
{
  "detail": [
    {
      "loc": ["body", "rating"],
      "msg": "ensure this value is less than or equal to 5",
      "type": "value_error.number.not_le"
    }
  ]
}

[Rule 4.38] 429 Too Many Requests
Triggered When:
  - Login rate limit exceeded (5 per minute)
Response: {"error": "Rate limit exceeded"}
Purpose: Prevent brute force attacks

[Rule 4.39] 500 Internal Server Error
Triggered When:
  - Database connection fails
  - Unexpected server-side exception
  - MongoDB query error
Response: {"detail": "Error fetching restaurants: [error]"}

=================================================================================
                          ADDITIONAL NOTES
=================================================================================

--- KNOWN LIMITATIONS (Current Implementation) ---

1. Agent Does NOT Support:
   - Order placement (place_order tool not implemented)
   - User authentication (no login/register tools)
   - Review submission (no review tools)
   - Order history lookup
   - Payment processing

2. Context Handling Issues:
   - Simple keyword matching (no NLP)
   - Cannot handle complex multi-turn conversations
   - May misinterpret ambiguous queries (e.g., "show me the menu" after 
     "tell me about Swati Snacks" may search for restaurant named "The Menu")

3. Tool Routing Limitations:
   - Cannot extract complex entity names from natural language
   - Relies on exact keyword matches
   - No fuzzy matching for restaurant/item names

4. No Confirmation Flow:
   - If order placement was implemented, it would need confirmation gate
   - Currently missing: "Is this correct? (yes/no)" step

--- SECURITY NOTES ---

1. Sensitive Data Protection:
   - SECRET_KEY loaded from environment variables (not hardcoded)
   - MongoDB credentials in .env file (not in code)
   - Passwords hashed with bcrypt (never stored plain text)
   - JWT tokens signed with SECRET_KEY

2. Input Validation:
   - All user inputs validated via Pydantic schemas
   - XSS protection on review comments
   - SQL injection not applicable (using MongoDB)
   - Rate limiting on authentication endpoints

3. Authentication:
   - Bearer token authentication (JWT)
   - Token expiration: 30 minutes
   - Secure password requirements enforced

4. Authorization:
   - Role-based access control (user vs admin)
   - Ownership checks (users can only modify their own data)
   - Admin-only endpoints properly protected

--- TESTING RECOMMENDATIONS ---

1. Test Invalid Inputs:
   - Quantity 0, -1, 101
   - Rating 0, 6
   - Empty strings, strings > max_length
   - Invalid email formats

2. Test Authorization:
   - Access admin endpoints without admin role (expect 403)
   - Update other users' reviews (expect 403)
   - Access protected endpoints without token (expect 401)

3. Test Business Logic:
   - Submit duplicate review (expect 400)
   - Order from non-existent restaurant (expect 404)
   - Login with wrong credentials (expect 401)

4. Test Agent Context:
   - Multi-turn conversations
   - Ambiguous queries
   - Edge cases in tool routing

=================================================================================
                              END OF DOCUMENTATION
=================================================================================

Generated: October 15, 2025
Project: FoodieExpress v4.0.0
Contact: For questions about this documentation, refer to source code or tests.
